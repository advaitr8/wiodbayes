#####################################
# Purpose of the R script
#####################################
#This R script attempts to read in a clean dataset from the private Github repo wiod_bayes

#Here I attempt to create the Leontief matrix from the A matrix and then explore its statistical properties
#####
#rm(list = ls())

#####################################
# Load the necessary packages
#####################################
#loading the necessary dataset
#this package pulls data from a GitHub repo
#install.packages("RCurl")
library(RCurl)

#this package loads .Rda files directly from GitHub
#install.packages("repmis")
library(repmis)

#load the Bayesian modeling language Stan
library(rstan)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
########################################

#load a package to do matrix powers
# install.packages("expm", dependencies = T)
library(expm)

####################################

#start by running the leontief_2.R so that the requisite rowsums and colsums are generated
source("leontief_2.R")
#######

#modeling rowsums with log-normal because the log of rowsums appears to be normal
str(row_sum_leon)
#first level is 15 years
#second level is 44 countries

#I want a list of 15 elements, where each element is a vector of row sum values from 44 countries, for each year
rowsums_eachyear_leon_list <- c()
for(i in 1:n_years){
  rowsums_eachyear_leon_list[[i]] <- unlist(as.vector(row_sum_leon[[i]]))
}

#making a country identifier, so now each element in rowsums_eachyear_leon_list has 2 columns, where the first is the row sum variable itself and the second is the country identifier.
country_identifier <- c()
for(i in 1:n_years){
  for(j in 1:n_countries){
    country_identifier <- c(country_identifier, c(length(row_sum_leon[[i]][[j]])))
  }
}

#repeat matrix takes the n_years*n_countries values of temp and puts them in a matrix, where each column corresponds to a unique year. Thus each column of this matrix will be the number of times each country id has to be repeated in a given year
repeat_matrix <- matrix(country_identifier,
                        nrow = n_countries,
                        ncol = n_years,
                        byrow = F)

##Now I make a list for just country id, this also has 15 elements for each year
c_id_list <- list()
for(i in 1:n_years){
  c_id_list[[i]] <- rep(1:n_countries,
                        times = repeat_matrix[,i])
}

##Now I make the final data set by pairing each country id vector with the rowsum vector for that year
for(i in 1:n_years){
  rowsums_eachyear_leon_list[[i]] <- cbind(rowsums_eachyear_leon_list[[i]],
                                      c_id_list[[i]])
}

#We expect a list of length 15, where each element is a long matrix with 2 columns, the first is the rowsum vector for that year and the second is the country id
str(rowsums_eachyear_leon_list)

#####################################
# Modeling rowsums with lognormal
#####################################
##making the data ready for modeling
#the list we are using rowsums_eachyear_leon_list
str(rowsums_eachyear_leon_list)
rowsums_leon <- rowsums_eachyear_leon_list[[1]][,1][rowsums_eachyear_leon_list[[1]][,1] != 0]
country_id_rowsums_leon <- rowsums_eachyear_leon_list[[1]][,2][rowsums_eachyear_leon_list[[1]][,1] != 0]
N <- length(rowsums_leon)

#empty list to store output
fit_rowsums_leon <- list()

#checking the Stan model and running it for just the first year, eventually use this compiled 
stanc("rowsums_leon.stan")
fit_rowsums_leon[[1]] <- stan("rowsums_leon.stan",
                         data = list("N",
                                     "n_countries",
                                     "rowsums_leon",
                                     "country_id_rowsums_leon"),
                         iter = 1000,
                         chains = 3)

for(i in 2:n_years){
  print(i)
  rowsums_leon <- rowsums_eachyear_leon_list[[i]][,1][rowsums_eachyear_leon_list[[i]][,1] != 0]
  country_id_rowsums_leon <- rowsums_eachyear_leon_list[[i]][,2][rowsums_eachyear_leon_list[[i]][,1] != 0]
  N <- length(rowsums_leon)
  fit_rowsums_leon[[i]] <- stan(fit = fit_rowsums_leon[[1]],
                           data = list("N",
                                       "n_countries",
                                       "rowsums_leon",
                                       "country_id_rowsums_leon"),
                           iter = 1000,
                           chains = 3)
}

save(fit_rowsums_leon,
     file = "/Users/Advait/Desktop/New_School/JH_networks/extra_storage_wiod_bayes/rda_files/fit_rowsums_leon.Rda")
#############################
# see if we can start by just loading the .Rda file here
#############################
# rm(list = ls())
# #load the rda file
load(file = "/Users/Advait/Desktop/New_School/JH_networks/extra_storage_wiod_bayes/rda_files/fit_rowsums_leon.Rda")

#make a list to store posterior 95% intervals of the relevant statistics
fit_rowsums_leon_PI <- list()
for(i in 1:n_years){
  fit_rowsums_leon_PI[[i]] <- as.data.frame(summary(fit_rowsums_leon[[i]],
                                                    probs = c(0.025, 0.975))$summary)
  fit_rowsums_leon_PI[[i]] <- fit_rowsums_leon_PI[[i]][-nrow(fit_rowsums_leon_PI[[i]]),]
}


leon_pred_means <- c()
for(i in 1:n_years){
  leon_pred_means <- c(leon_pred_means, fit_rowsums_leon_PI[[i]]$mean[-c(1:48)])
}

#add the predictions to the rowsum log histogram
lines(density(leon_pred_means))

####making posterior predictive check plots
plot(leon_pred_means,
     log(unlist(row_sum_leon)[unlist(row_sum_leon) != 0]),
     pch = 16,
     cex = 0.6,
     xlim = c(-6,3),
     ylim = c(-6,3))
abline(0,1)
