fit5 <- fit_wiod(statistic = statistic,
model = "skew_normal",
pooling = "complete")
library(wiodbayes)
fit5 <- fit_wiod(statistic = statistic,
model = "skew_normal",
pooling = "complete")
fit5
library(wiodbayes)
fit5 <- fit_wiod(statistic = statistic,
model = "skew_normal",
pooling = "complete")
fit5
library(wiodbayes)
fit6
fit6 <- fit_wiod(statistic = statistic,
levels_id_vector = levels_id_indicator
model = "skew_normal",
pooling = "partial")
fit6 <- fit_wiod(statistic = statistic,
levels_id_vector = levels_id_indicator,
model = "skew_normal",
pooling = "partial")
fit6 <- fit_wiod(statistic = statistic,
levels_id_vector = levels_id_indicator,
model = "skew_normal",
pooling = "partial")
library(wiodbayes)
library(wiodbayes)
#####################################
# Purpose of the R script
#####################################
#This R script attempts to read in a clean dataset from the private Github repo wiod_bayes
#Here I attempt to create the Leontief matrix from the A matrix and then explore its statistical properties
#####
#rm(list = ls())
#####################################
# Load the necessary packages
#####################################
#loading the necessary dataset
#this package pulls data from a GitHub repo
#install.packages("RCurl")
library(RCurl)
#this package loads .Rda files directly from GitHub
#install.packages("repmis")
library(repmis)
#load the Bayesian modeling language Stan
library(rstan)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
########################################
#load a package to do matrix powers
# install.packages("expm", dependencies = T)
library(expm)
####################################
#start by running the leontief_2.R so that the requisite rowsums and colsums are generated
source("leontief_2.R")
#######
#modeling rowsums with log-normal because the log of rowsums appears to be normal
str(row_sum_leon)
#first level is 15 years
#second level is 44 countries
#I want a list of 15 elements, where each element is a vector of row sum values from 44 countries, for each year
rowsums_eachyear_leon_list <- c()
for(i in 1:n_years){
rowsums_eachyear_leon_list[[i]] <- unlist(as.vector(row_sum_leon[[i]]))
}
#making a country identifier, so now each element in rowsums_eachyear_leon_list has 2 columns, where the first is the row sum variable itself and the second is the country identifier.
country_identifier <- c()
for(i in 1:n_years){
for(j in 1:n_countries){
country_identifier <- c(country_identifier, c(length(row_sum_leon[[i]][[j]])))
}
}
#repeat matrix takes the n_years*n_countries values of temp and puts them in a matrix, where each column corresponds to a unique year. Thus each column of this matrix will be the number of times each country id has to be repeated in a given year
repeat_matrix <- matrix(country_identifier,
nrow = n_countries,
ncol = n_years,
byrow = F)
##Now I make a list for just country id, this also has 15 elements for each year
c_id_list <- list()
for(i in 1:n_years){
c_id_list[[i]] <- rep(1:n_countries,
times = repeat_matrix[,i])
}
##Now I make the final data set by pairing each country id vector with the rowsum vector for that year
for(i in 1:n_years){
rowsums_eachyear_leon_list[[i]] <- cbind(rowsums_eachyear_leon_list[[i]],
c_id_list[[i]])
}
#We expect a list of length 15, where each element is a long matrix with 2 columns, the first is the rowsum vector for that year and the second is the country id
str(rowsums_eachyear_leon_list)
#####################################
# Modeling rowsums with lognormal
#####################################
##making the data ready for modeling
#the list we are using rowsums_eachyear_leon_list
str(rowsums_eachyear_leon_list)
rowsums_leon <- rowsums_eachyear_leon_list[[1]][,1][rowsums_eachyear_leon_list[[1]][,1] != 0]
country_id_rowsums_leon <- rowsums_eachyear_leon_list[[1]][,2][rowsums_eachyear_leon_list[[1]][,1] != 0]
N <- length(rowsums_leon)
#empty list to store output
fit_rowsums_leon <- list()
#checking the Stan model and running it for just the first year, eventually use this compiled
stanc("rowsums_leon.stan")
fit_rowsums_leon[[1]] <- stan("rowsums_leon.stan",
data = list("N",
"n_countries",
"rowsums_leon",
"country_id_rowsums_leon"),
iter = 1000,
chains = 3)
for(i in 2:n_years){
print(i)
rowsums_leon <- rowsums_eachyear_leon_list[[i]][,1][rowsums_eachyear_leon_list[[i]][,1] != 0]
country_id_rowsums_leon <- rowsums_eachyear_leon_list[[i]][,2][rowsums_eachyear_leon_list[[i]][,1] != 0]
N <- length(rowsums_leon)
fit_rowsums_leon[[i]] <- stan(fit = fit_rowsums_leon[[1]],
data = list("N",
"n_countries",
"rowsums_leon",
"country_id_rowsums_leon"),
iter = 1000,
chains = 3)
}
save(fit_rowsums_leon,
file = "/Users/Advait/Desktop/New_School/JH_networks/extra_storage_wiod_bayes/rda_files/fit_rowsums_leon.Rda")
#############################
# see if we can start by just loading the .Rda file here
#############################
# rm(list = ls())
# #load the rda file
load(file = "/Users/Advait/Desktop/New_School/JH_networks/extra_storage_wiod_bayes/rda_files/fit_rowsums_leon.Rda")
#make a list to store posterior 95% intervals of the relevant statistics
fit_rowsums_leon_PI <- list()
for(i in 1:n_years){
fit_rowsums_leon_PI[[i]] <- as.data.frame(summary(fit_rowsums_leon[[i]],
probs = c(0.025, 0.975))$summary)
fit_rowsums_leon_PI[[i]] <- fit_rowsums_leon_PI[[i]][-nrow(fit_rowsums_leon_PI[[i]]),]
}
leon_pred_means <- c()
for(i in 1:n_years){
leon_pred_means <- c(leon_pred_means, fit_rowsums_leon_PI[[i]]$mean[-c(1:48)])
}
#add the predictions to the rowsum log histogram
lines(density(leon_pred_means))
####making posterior predictive check plots
plot(leon_pred_means,
log(unlist(row_sum_leon)[unlist(row_sum_leon) != 0]),
pch = 16,
cex = 0.6,
xlim = c(-6,3),
ylim = c(-6,3))
abline(0,1)
#####################################
# Purpose of the R script
#####################################
#This R script attempts to read in a clean dataset from the private Github repo wiod_bayes
#Here I attempt to create the Leontief matrix from the A matrix and then explore its statistical properties
#####
#rm(list = ls())
#####################################
# Load the necessary packages
#####################################
#loading the necessary dataset
#this package pulls data from a GitHub repo
#install.packages("RCurl")
library(RCurl)
#this package loads .Rda files directly from GitHub
#install.packages("repmis")
library(repmis)
#load the Bayesian modeling language Stan
library(rstan)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
########################################
#load a package to do matrix powers
# install.packages("expm", dependencies = T)
library(expm)
#####################################
# Exploring and cleaning the data
#####################################
#load the WIOD dataset
load("/Users/Advait/Desktop/New_School/JH_networks/extra_storage_wiod_bayes/rda_files/WIOT_Cleaned_Country.Rda")
#The first level is the year, so there are 15 years
length(norm_a_list_all)
n_years <- length(norm_a_list_all)
#The second level is country, so there are 44 countries
length(norm_a_list_all[[1]])
n_countries <- length(norm_a_list_all[[1]])
##this is the A matrix for year 1 country 1
dim(norm_a_list_all[[1]][[1]])
##I want to make each and every A matrix into a Leontief matrix by adding the power series upto the 4th power
######
# A matrix to the first power
######
first <- norm_a_list_all
#####
# A matrix to the second power
#####
second <- norm_a_list_all
for(i in 1:n_years){
for(j in 1:n_countries){
second[[i]][[j]] <- (norm_a_list_all[[i]][[j]]) %^% 2
}
}
#####
# A matrix to the third power
#####
third <- norm_a_list_all
for(i in 1:n_years){
for(j in 1:n_countries){
third[[i]][[j]] <- (norm_a_list_all[[i]][[j]]) %^% 3
}
}
#####
# A matrix to the fourth power
#####
fourth <- norm_a_list_all
for(i in 1:n_years){
for(j in 1:n_countries){
fourth[[i]][[j]] <- (norm_a_list_all[[i]][[j]]) %^% 4
}
}
#####
# the Leontief matrix
#####
leontief <- norm_a_list_all
for(i in 1:n_years){
for(j in 1:n_countries){
leontief[[i]][[j]] <- first[[i]][[j]]+second[[i]][[j]]+third[[i]][[j]]+fourth[[i]][[j]]
}
}
#################################
##Exploring the Leontief matrices
#################################
### taken from ?Reduce
#this function will add a list of matrices
add <- function(x) Reduce("+", x)
##########
#rowsums
##########
row_sum_leon <- norm_a_list_all
for(i in 1:n_years){
for(j in 1:n_countries){
row_sum_leon[[i]][[j]] <- rowSums(leontief[[i]][[j]])
}
}
#making some plots
#plot the rowsums for all countries at once
pdf('leon_rowsums_all.pdf', height = 8, width = 8)
plot(density(row_sum_leon[[1]][[1]]),
xlim = c(0,10),
ylim = c(0,1),
main = "density of log rowsums Leontief")
for(i in 1:n_years){
for(j in 1:n_countries){
lines(density(row_sum_leon[[i]][[j]]))
}
}
dev.off()
#plot the rowsums histogram for all countries at once
# pdf('leon_rowsums_hist_all.pdf', height = 8, width = 8)
hist(unlist(row_sum_leon),
col = "gray",
freq = F,
breaks = 65,
main = "histogram of rowsums of Leontief",
xlab = "rowsum Leontief")
# dev.off()
#plot the log of rowsums for all countries at once
pdf('log_leon_rowsums_all.pdf', height = 8, width = 8)
plot(density(log(row_sum_leon[[1]][[1]])),
xlim = c(-5,5),
ylim = c(0,0.7),
main = "density of log rowsums Leontief")
for(i in 1:n_years){
for(j in 1:n_countries){
lines(density(log(row_sum_leon[[i]][[j]])))
}
}
dev.off()
#plot the log rowsums histograms for all countries at once
hist(log(unlist(row_sum_leon)),
col = "gray",
freq = F,
breaks = 65,
main = "histogram of log rowsums of Leontief",
xlab = "log rowsum Leontief",
ylim = c(0,0.6))
# plot rowsums by country (average over 15 years)
rowsums_each_year <- list()
for(j in 1:n_countries){
for(i in 1:n_years){
rowsums_each_year[[j]] <- add(list(row_sum_leon[[i]][[j]]))
}
}
#taking average divide by 15
rowsums_each_year_avg <- list()
for(j in 1:n_countries){
rowsums_each_year_avg[[j]] <- rowsums_each_year[[j]]/15
}
#plot rowsums of all countries separately
pdf('leon_rowsums_countries.pdf', height = 15, width = 15)
par(mfrow = c(9,5))
for(j in 1:n_countries){
plot(density(rowsums_each_year_avg[[j]]),
main = paste("log rowsums", country_id[j]),
xlim = c(0,0.7),
ylim = c(0,10)
)
}
dev.off()
#plot log rowsums of all countries separately
pdf('log_leon_rowsums_countries.pdf', height = 15, width = 15)
par(mfrow = c(9,5))
for(j in 1:n_countries){
plot(density(log(rowsums_each_year_avg[[j]])),
main = paste("log rowsums", country_id[j]),
xlim = c(-8,1),
ylim = c(0,0.5)
)
}
dev.off()
##########
#colsums
##########
col_sum_leon <- norm_a_list_all
for(i in 1:n_years){
for(j in 1:n_countries){
col_sum_leon[[i]][[j]] <- colSums(leontief[[i]][[j]])
}
}
range(col_sum_leon)
#making some plots
#plot the colsums for all countries at once
pdf('leon_colsums_all.pdf', height = 8, width = 8)
plot(density(col_sum_leon[[1]][[1]]),
xlim = c(0,3.2),
ylim = c(0,2),
main = "density of colsums Leontief")
for(i in 1:n_years){
for(j in 1:n_countries){
lines(density(col_sum_leon[[i]][[j]]))
}
}
dev.off()
#plot the log of rowsums for all countries at once
pdf('log_leon_colsums_all.pdf', height = 8, width = 8)
plot(density(log(col_sum_leon[[1]][[1]])),
xlim = c(-3,1.5),
ylim = c(0,2.2),
main = "density of log colsums Leontief")
for(i in 1:n_years){
for(j in 1:n_countries){
lines(density(log(col_sum_leon[[i]][[j]])))
}
}
dev.off()
# plot colsums by country (average over 15 years)
colsums_each_year <- list()
for(j in 1:n_countries){
for(i in 1:n_years){
colsums_each_year[[j]] <- add(list(col_sum_leon[[i]][[j]]))
}
}
#taking average divide by 15
colsums_each_year_avg <- list()
for(j in 1:n_countries){
colsums_each_year_avg[[j]] <- colsums_each_year[[j]]/15
}
#plot colsums of all countries separately
pdf('leon_colsums_countries.pdf', height = 15, width = 15)
par(mfrow = c(9,5))
for(j in 1:n_countries){
plot(density(colsums_each_year_avg[[j]]),
main = paste("log colsums", country_id[j]),
# xlim = c(-8,1),
# ylim = c(0,0.5)
)
}
dev.off()
#modeling rowsums with log-normal because the log of rowsums appears to be normal
str(row_sum_leon)
#first level is 15 years
#second level is 44 countries
#I want a list of 15 elements, where each element is a vector of row sum values from 44 countries, for each year
rowsums_eachyear_leon_list <- c()
for(i in 1:n_years){
rowsums_eachyear_leon_list[[i]] <- unlist(as.vector(row_sum_leon[[i]]))
}
#making a country identifier, so now each element in rowsums_eachyear_leon_list has 2 columns, where the first is the row sum variable itself and the second is the country identifier.
country_identifier <- c()
for(i in 1:n_years){
for(j in 1:n_countries){
country_identifier <- c(country_identifier, c(length(row_sum_leon[[i]][[j]])))
}
}
#repeat matrix takes the n_years*n_countries values of temp and puts them in a matrix, where each column corresponds to a unique year. Thus each column of this matrix will be the number of times each country id has to be repeated in a given year
repeat_matrix <- matrix(country_identifier,
nrow = n_countries,
ncol = n_years,
byrow = F)
##Now I make a list for just country id, this also has 15 elements for each year
c_id_list <- list()
for(i in 1:n_years){
c_id_list[[i]] <- rep(1:n_countries,
times = repeat_matrix[,i])
}
##Now I make the final data set by pairing each country id vector with the rowsum vector for that year
for(i in 1:n_years){
rowsums_eachyear_leon_list[[i]] <- cbind(rowsums_eachyear_leon_list[[i]],
c_id_list[[i]])
}
#We expect a list of length 15, where each element is a long matrix with 2 columns, the first is the rowsum vector for that year and the second is the country id
str(rowsums_eachyear_leon_list)
#####################################
# Modeling rowsums with lognormal
#####################################
##making the data ready for modeling
#the list we are using rowsums_eachyear_leon_list
str(rowsums_eachyear_leon_list)
rowsums_leon <- rowsums_eachyear_leon_list[[1]][,1][rowsums_eachyear_leon_list[[1]][,1] != 0]
country_id_rowsums_leon <- rowsums_eachyear_leon_list[[1]][,2][rowsums_eachyear_leon_list[[1]][,1] != 0]
N <- length(rowsums_leon)
#empty list to store output
fit_rowsums_leon <- list()
#checking the Stan model and running it for just the first year, eventually use this compiled
stanc("rowsums_leon.stan")
fit_rowsums_leon[[1]] <- stan("rowsums_leon.stan",
data = list("N",
"n_countries",
"rowsums_leon",
"country_id_rowsums_leon"),
iter = 1000,
chains = 3)
for(i in 2:n_years){
print(i)
rowsums_leon <- rowsums_eachyear_leon_list[[i]][,1][rowsums_eachyear_leon_list[[i]][,1] != 0]
country_id_rowsums_leon <- rowsums_eachyear_leon_list[[i]][,2][rowsums_eachyear_leon_list[[i]][,1] != 0]
N <- length(rowsums_leon)
fit_rowsums_leon[[i]] <- stan(fit = fit_rowsums_leon[[1]],
data = list("N",
"n_countries",
"rowsums_leon",
"country_id_rowsums_leon"),
iter = 1000,
chains = 3)
}
save(fit_rowsums_leon,
file = "/Users/Advait/Desktop/New_School/JH_networks/extra_storage_wiod_bayes/rda_files/fit_rowsums_leon.Rda")
#############################
# see if we can start by just loading the .Rda file here
#############################
# rm(list = ls())
# #load the rda file
load(file = "/Users/Advait/Desktop/New_School/JH_networks/extra_storage_wiod_bayes/rda_files/fit_rowsums_leon.Rda")
#make a list to store posterior 95% intervals of the relevant statistics
fit_rowsums_leon_PI <- list()
for(i in 1:n_years){
fit_rowsums_leon_PI[[i]] <- as.data.frame(summary(fit_rowsums_leon[[i]],
probs = c(0.025, 0.975))$summary)
fit_rowsums_leon_PI[[i]] <- fit_rowsums_leon_PI[[i]][-nrow(fit_rowsums_leon_PI[[i]]),]
}
leon_pred_means <- c()
for(i in 1:n_years){
leon_pred_means <- c(leon_pred_means, fit_rowsums_leon_PI[[i]]$mean[-c(1:48)])
}
#add the predictions to the rowsum log histogram
lines(density(leon_pred_means))
####making posterior predictive check plots
plot(leon_pred_means,
log(unlist(row_sum_leon)[unlist(row_sum_leon) != 0]),
pch = 16,
cex = 0.6,
xlim = c(-6,3),
ylim = c(-6,3))
abline(0,1)
statistic <- c()
levels_id_indicator <- c()
for(i in 1:15){
statistic <- c(statistic,
unlist(rowsums_eachyear_leon_list[[i]][,1]))
levels_id_indicator <- c(levels_id_indicator,
unlist(rowsums_eachyear_leon_list[[i]][,2]))
}
cbind(statistic,levels_id_indicator)
fit3 <- fit_wiod(statistic = statistic,
levels_id_vector = levels_id_indicator,
model = "normal",
pooling = "none")
library(wiodbayes)
fit3 <- fit_wiod(statistic = statistic,
levels_id_vector = levels_id_indicator,
model = "normal",
pooling = "none")
fit3
fit5 <- fit_wiod(statistic = statistic,
levels_id_vector = levels_id_indicator,
model = "lognormal",
pooling = "none")
fit5
fit8 <- fit_wiod(statistic = statistic,
levels_id_vector = levels_id_indicator,
model = "skew_normal",
pooling = "none")
library(wiodbayes)
fit5 <- fit_wiod(statistic = statistic,
levels_id_vector = levels_id_indicator,
model = "lognormal",
pooling = "none")
fit5
